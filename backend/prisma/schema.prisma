// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  name      String
  email     String?  @unique
  phone     String?  @unique
  address   Address? @relation(name: "UserAddress", fields: [addressId], references: [id])
  addressId String?  @unique
  password  String

  fcmToken       String?
  whatsappNumber String?

  isEmailVerified Boolean @default(false)
  isPhoneVerified Boolean @default(false)

  loyaltyStatus       LoyaltyStatus?       @default(BRONZE)
  otpSessions         OTPSession[]
  bookings            ServiceBooking[]
  subscriptions       Subscription[]
  tdsLogs             TDSLog[]
  notifications       Notification[]
  whatsappLogs        WhatsAppLog[]
  passwordResetTokens PasswordResetToken[]
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  PaymentOrder        PaymentOrder[]
}

model Address {
  id         String @id @default(uuid())
  street     String
  city       String
  state      String
  postalCode String
  country    String

  user User? @relation(name: "UserAddress")
}

model PasswordResetToken {
  id         String    @id @default(uuid())
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  token      String    @unique
  plainToken String
  expiresAt  DateTime
  usedAt     DateTime?
  createdAt  DateTime  @default(now())

  @@index([userId])
  @@index([expiresAt])
}

enum LoyaltyStatus {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

model Admin {
  id        String              @id @default(uuid())
  name      String
  email     String              @unique
  password  String // hashed password
  role      AdminRole           @default(STAFF)
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt
  services  ServiceDefinition[]
}

enum AdminRole {
  SUPERADMIN
  STAFF
}

model Product {
  id          String             @id @default(uuid())
  name        String
  price       Decimal
  description String?
  image       String?
  inventory   Int
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  orderItems  PaymentOrderItem[]
}

model ServiceDefinition {
  id          String      @id @default(uuid())
  name        String
  description String?
  type        ServiceType
  image       String?
  price       Decimal?

  duration Int?
  isActive Boolean @default(true)

  createdBy Admin  @relation(fields: [adminId], references: [id])
  adminId   String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bookings ServiceBooking[]
}

model ServiceBooking {
  id     String @id @default(uuid())
  user   User   @relation(fields: [userId], references: [id])
  userId String

  service   ServiceDefinition @relation(fields: [serviceId], references: [id])
  serviceId String

  slot   Slot   @relation(fields: [slotId], references: [id])
  slotId String

  status         ServiceStatus @default(PENDING)
  beforeImageUrl String?
  afterImageUrl  String?

  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  PaymentOrder PaymentOrder[]
}

model Slot {
  id        String           @id @default(uuid())
  startTime DateTime
  endTime   DateTime
  bookings  ServiceBooking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum ServiceType {
  AMC
  URGENT
}

enum ServiceStatus {
  PENDING
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  PAYMENT_INCOMPLETE
}

model SubscriptionPlan {
  id          String   @id @default(uuid())
  name        String
  description String?
  price       Decimal
  duration    Int
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // A plan can be purchased by many users
  subscriptions Subscription[]
}

model Subscription {
  id     String @id @default(uuid())
  user   User   @relation(fields: [userId], references: [id])
  userId String

  plan   SubscriptionPlan @relation(fields: [planId], references: [id])
  planId String

  startDate    DateTime
  endDate      DateTime
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  status       SubscriptionPaymentStatus @default(PENDING)
  PaymentOrder PaymentOrder[]
}

enum SubscriptionPaymentStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

model TDSLog {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  tdsValue  Int
  timestamp DateTime @default(now())
}

model Notification {
  id        String             @id @default(uuid())
  user      User               @relation(fields: [userId], references: [id])
  userId    String
  type      NotificationType
  message   String
  status    NotificationStatus
  sentAt    DateTime?
  createdAt DateTime           @default(now())
}

enum NotificationType {
  FCM
  WHATSAPP
  EMAIL
}

enum NotificationStatus {
  SENT
  PENDING
  FAILED
}

model WhatsAppLog {
  id          String              @id @default(uuid())
  user        User                @relation(fields: [userId], references: [id])
  userId      String
  messageType WhatsAppMessageType
  content     String
  timestamp   DateTime            @default(now())
}

enum WhatsAppMessageType {
  TEXT
  BUTTON
  IMAGE
  VIDEO
  AUDIO
}

model OTPSession {
  id        String     @id @default(uuid())
  user      User       @relation(fields: [userId], references: [id])
  userId    String
  otpCode   String
  channel   OTPChannel
  expiresAt DateTime
  verified  Boolean    @default(false)
  createdAt DateTime   @default(now())
}

enum OTPChannel {
  EMAIL
  PHONE
}

model ContactMessage {
  id        String   @id @default(uuid())
  name      String
  email     String
  message   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model PaymentOrder {
  id              String         @id @default(uuid())
  razorpayOrderId String         @unique // Razorpay-generated order_id
  amount          Decimal
  currency        String         @default("INR")
  status          PaymentStatus  @default(PENDING)
  purpose         PaymentPurpose // booking, subscription, product purchase
  user            User           @relation(fields: [userId], references: [id])
  userId          String

  booking   ServiceBooking? @relation(fields: [bookingId], references: [id])
  bookingId String?

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?

  items PaymentOrderItem[]

  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  transaction PaymentTransaction?
}

model PaymentTransaction {
  id           String       @id @default(uuid())
  paymentOrder PaymentOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId      String       @unique

  razorpayPaymentId String?       @unique // Razorpay-generated payment_id (unique to prevent duplicates)
  razorpaySignature String? // for verification
  status            PaymentStatus
  method            String? // UPI, CARD, WALLET, etc.
  amountPaid        Decimal?
  capturedAt        DateTime?
  errorReason       String?

  createdAt DateTime @default(now())
}

model PaymentOrderItem {
  id      String       @id @default(uuid())
  order   PaymentOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId String

  product   Product @relation(fields: [productId], references: [id])
  productId String

  quantity Int     @default(1)
  price    Decimal
  subtotal Decimal

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
  CANCELLED
}

enum PaymentPurpose {
  SERVICE_BOOKING
  SUBSCRIPTION
  PRODUCT_PURCHASE
  OTHER
}
